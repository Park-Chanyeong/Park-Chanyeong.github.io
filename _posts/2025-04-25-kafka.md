---
layout: single
title: "데이터레이크 아키텍처 설계 (람다 vs 카파 아키텍처)"
categories: DataEngineering
tag: [kafka]
search: true
typora-root-url: ../
sidebar:
  nav: "counts"







---



**[**Kafka][데이터레이크 아키텍처 설계 (람다 vs 카파 아키텍처) ](https://park-chanyeong.github.io)
{: .notice--primary}

# 1. 시작하며

데이터 파이프라인 설계할 때 가장 헷갈리는 것 중 하나가 아키텍처 구조 선택임.  
배치만 쓸지, 실시간도 엮을지, 람다를 쓸지, 카파를 쓸지...  

나도 공부하면서 여러 개념들이 머릿속에서 뒤엉켰던 적이 많았음.  
이번 포스팅에서는 실제 실무에서 고려할 수 있는 **람다 아키텍처**, **카파 아키텍처**, 그리고 **데이터레이크 일반 설계 사례**까지 싹 정리해보려고 함.

> 아키텍처는 상황 따라 다르다 = 정답 없음  
> 그래도 개념은 알고 있어야 선택이라도 하지

---

# 2. 람다 아키텍처: 배치 + 실시간의 공존

## 2-1. 람다 아키텍처란?

람다 아키텍처는 **Nathan Marz**가 제안한 구조로, **배치 처리와 실시간 처리 둘 다 사용하는 형태**임.  
간단히 말하면, D-1 기준의 정제된 데이터는 배치로 처리하고,  
**오늘 발생한 데이터는 실시간 처리 레이어(Speed Layer)에서 담당**하는 구조.

### 구조 요약

![람다 아키텍처 (Lambda Architecture) | Databricks](https://www.databricks.com/sites/default/files/inline-images/hadoop-architecture.png?v=1673967407)

- **Batch Layer**: 마스터/정제 데이터 저장
- **Speed Layer**: 실시간 유입 데이터 처리
- **Serving Layer**: 사용자에게 결과 제공

```text
[Data Source]
     |
[Batch Layer] ---\
                 |---> [Serving Layer] ---> Query
[Speed Layer] ---/
```

## 2-2. 각 레이어의 역할

- **Batch Layer**
  - 마스터성 테이블 관리 (ex. 고객 마스터, 제품 마스터)
  - 하루 1~2회 갱신
- **Speed Layer**
  - 오늘 유입된 데이터 처리 (ex. 오늘의 주문 금액)
  - 배치 갱신 이후 들어온 데이터 중심
- **Serving Layer**
  - 최종적으로 사용자가 접근하는 계층
  - 배치 + 실시간 결과를 조합해 제공하기도 함

## 2-3. 언제 써야 함?

- 실시간성 + 정합성 둘 다 필요한 상황
- 예) 고객 마스터(배치) + 고객 행동 로그(실시간)를 조인해서 분석해야 하는 경우

## 2-4. 단점도 있음

- 두 개의 파이프라인 유지 필요 → 운영/관리 복잡도 증가
- 같은 데이터를 배치/실시간 둘 다 처리해야 하는 경우도 발생함

------

# 3. 카파 아키텍처: 실시간만으로 승부

## 3-1. 카파 아키텍처란?

![image-20250426020635934](/images/2025-04-25-kafka/image-20250426020635934.png)

람다 구조의 복잡함을 해결하고자 **Jay Kreps**가 제안한 모델임.
 Kafka 만든 그 양반 맞음.
 람다에서의 **Batch Layer를 제거하고, 전부 Speed Layer에서 처리**하는 구조임.

```text
[Kafka (Message Queue)] 
     |
[Speed Layer (ex. Spark Streaming)]
     |
[Serving Layer]
```

## 3-2. 핵심 철학

- 배치 없이도 충분히 처리 가능하다
- Kafka가 과거 데이터도 저장할 수 있으니, 거기서 다시 리플레이 하면 됨
- 하나의 파이프라인만 관리하면 되니까 구조가 단순해짐

## 3-3. 카파가 좋은 상황

- **실시간 중심** 서비스
- **이벤트 기반** 데이터 처리
- **배치 따위 필요 없는 경우**

> ex) 실시간 알림 시스템, 실시간 로그 분석 등

## 3-4. 근데 국내 사례는?

- 현실에서는 잘 안 쓰임...
- 대부분은 아직도 **배치 중심** 혹은 **람다 혼합형 구조**로 많이 구현하고 있음

------

# 4. 데이터레이크 일반 설계 예시

## 4-1. 아키텍처 구성 흐름

데이터레이크 설계 시 일반적인 구성을 그려보면 아래처럼 됨:

```text
[데이터 수집]
     ↓
[저장] - S3, HDFS
     ↓
[처리] - Spark, Flink, Hive
     ↓
[제공] - Athena, Presto, Trino
     ↓
[활용] - 대시보드, ML, BI Tool 등
```

각 단계마다 선택할 수 있는 솔루션은 다양하고, 목적/환경에 따라 달라짐.

## 4-2. 솔루션 예시 모음

![image-20250426020834855](/images/2025-04-25-kafka/image-20250426020834855.png)

| 단계 | 예시                                   |
| ---- | -------------------------------------- |
| 수집 | Kafka, Airflow, NiFi, Debezium         |
| 저장 | HDFS, S3, DeltaLake                    |
| 처리 | Spark, Flink, Hive, Samza              |
| 제공 | Athena, Presto, Trino, Greenplum       |
| 활용 | Tableau, Superset, Gen AI, 대시보드 등 |

## 4-3. 실습 예시 구조

```text
[공공데이터 API]
     ↓
[Kafka] → [Spark Streaming]
     ↓
[S3 / DeltaLake] + [Redis]
     ↓
[Athena / 대시보드]
```

------

# 5. 람다 vs 카파 vs 그냥 배치



| 항목     | 람다 아키텍처                 | 카파 아키텍처          | 배치 Only        |
| -------- | ----------------------------- | ---------------------- | ---------------- |
| 실시간성 | O                             | O                      | X                |
| 유지보수 | 복잡                          | 단순                   | 단순             |
| 구조     | 배치 + 실시간 이중 파이프라인 | 실시간 단일 파이프라인 | 배치 한방        |
| 적용사례 | 일반적인 기업 데이터 분석     | 실시간 이벤트 처리     | 정기 집계 보고서 |

> 결론은? "상황 따라 다르다"

------

# 6. 마무리

정리하자면,

- **람다**는 배치와 실시간을 모두 사용해야 할 때 적합
- **카파**는 실시간 기반으로 최대한 단순하게 가져갈 수 있는 구조
- 그리고 **배치만 써도 충분한 경우도 많다**

실제로는 람다 아키텍처 기반으로 시작해서 필요 시 일부만 실시간 처리하는 경우도 많고,
 정말 극한의 실시간 처리가 필요하면 카파를 염두에 두는 정도라고 보면 될 듯 함.