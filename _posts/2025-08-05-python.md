---
layout: single
title: "5 Good Python Habits?"
categories: python
tag: [python]
search: true
typora-root-url: ../
sidebar:
  nav: "counts"








---



**[Python][5 Good Python Habits](https://park-chanyeong.github.io)**
{: .notice--primary}



## 1) `if __name__ == "__main__":`로  “임포트 시 실행” 절연하기

### 왜 필요한가?

임포트 시 파이썬은 모듈 파일을 **통째로 로드**하는데, 파일 하단에 테스트용 실행 코드가 있으면 **임포트만 해도 실행**됨 

결과적으로, 메인 스크립트에서 함수를 호출할 때와 **임포트 시점**에 **두 번** 실행되는 일이 생김<br>

### 올바른 구조

```python
# internet.py
def connect():
    print("connected")
    # 실제 네트워크 처리...

if __name__ == "__main__":
    # 모듈 단독 실행 시에만 돌아감 (테스트/데모용)
    connect()
# main.py
from internet import connect

if __name__ == "__main__":
    # 메인 스크립트의 의도된 진입점
    connect()
```

- **테스트/실행 분리**: 모듈을 임포트해도 테스트 코드가 돌지 않음.
- **스크립트 오인 실행 방지**: 편집기의 “실행” 버튼(녹색 화살표 등)으로 현재 파일만 실행하기 쉬움.
- **자체 문서화**: “이 스크립트는 직접 실행 대상임”을 명확히 드러냄.

------

## 2) `main()` 엔트리포인트로 흐름을 한눈에

### 권장 패턴

```python
def main() -> None:
    greet("Alice")
    say_goodbye("Alice")

def greet(name: str) -> None:
    print(f"Hello, {name}")

def say_goodbye(name: str) -> None:
    print(f"Bye, {name}")

if __name__ == "__main__":
    main()
```

- “무엇을 먼저/다음에 하는지”가 **한 함수**에 모여 있어 가독성↑.
- 편집기 **라이브 템플릿**(예: PyCharm)으로 `main` 스니펫을 등록해 보일러플레이트 최소화.
- 다른 언어(자바 등)의 **진입점 패턴**과 유사해 협업자도 바로 이해.

------

## 3) 함수는 **작게**, **한 가지 일만**, **재사용 가능**하게

### 나쁜 예 — 모든 로직을 한 그릇에

```python
# 단일 거대 함수: 재사용/테스트/수정 난이도↑
def enter_club(name: str, age: int, has_id: bool) -> bool:
    if name.lower() == "bob":   # 블랙리스트
        print("Bob, get out.")
        return False
    if not has_id or age < 21:  # 성인+신분증
        return False
    return True
```

### 좋은 예 — 로직 분리

```python
BLACKLIST = {"bob"}

def is_blacklisted(name: str) -> bool:
    return name.lower() in BLACKLIST

def is_adult_with_valid_id(age: int, has_id: bool) -> bool:
    return has_id and age >= 21
    # 필요하면 is_valid_id() 같은 하위 함수로 더 분해

def enter_club(name: str, age: int, has_id: bool) -> bool:
    if is_blacklisted(name):
        print(f"{name}, get out.")
        return False
    if not is_adult_with_valid_id(age, has_id):
        return False
    return True
```

### 이점

- **재사용성**: `is_blacklisted`, `is_adult_with_valid_id`를 다른 문맥에서도 그대로 사용.
- **변경 용이성**: 정책이 바뀌어도 **정확히 어느 함수**를 고치면 되는지 명확.
- **테스트 용이성**: 작은 함수 단위로 독립 테스트 가능.

------

## 4) 타입 애너테이션 + 정적 타입 체커(`mypy`)로 품질 상승

### 변수/함수에 타입 명시

```python
# 변수
count: int = 10        # 잘못 10.0( float )을 넣으면 IDE에서 경고 가능
title: str = "Hello"

# 함수 시그니처 = 곧 문서
from typing import List

def upper_all(elements: List[str]) -> List[str]:
    return [e.upper() for e in elements]
```

- **자체 문서화**: 인자/반환 타입이 시그니처에 드러나 별도의 “중복 문서”가 불필요.
- **IDE 지원↑**: 적절한 자동완성·경고 제공(문자열 메서드 힌트 등).

### 편집기가 못 잡는 것도 `mypy`는 잡는다

```python
from typing import List
nums: List[int] = [1, "2", 3]  # 편집기는 넘어가도, mypy는 오류로 잡아줄 수 있음
# 설치
pip install mypy

# 검사
mypy main.py
# 예) error: List item 1 has incompatible type "str"; expected "int"
```

- **CI에 mypy 추가**: PR 단계에서 타입 오류 차단 → 런타임 사고 감소.
- **실행 성능 영향 없음**: 애너테이션은 선택적이며 런타임에는 강제되지 않음(검사는 정적 도구가 수행).

------

## 5) 리스트 컴프리헨션으로 간결·고성능 변환/필터

### 전통적 반복문

```python
people = ["James", "Charlotte", "Stephanie", "Mario", "Sandra"]
long_names = []
for p in people:
    if len(p) > 7:
        long_names.append(p)
print(long_names)  # ["Charlotte", "Stephanie"]
```

### 리스트 컴프리헨션

```python
names = ["James", "Charlotte", "Stephanie", "Mario", "Sandra"]
long_names = [name for name in names if len(name) > 7]
print(long_names)  # ["Charlotte", "Stephanie"]
```

- **더 짧고 빠름**. 간단한 필터·매핑 작업에 적합.
- **가독성 유지 포인트**: `p`보다 `name`처럼 **의미 있는 변수명** 사용. 너무 복잡해지면 **함수로 분리**.

### 변환 예 (대문자화 + 조건)

```
python복사편집emails = ["a@example.com", "info@test.com", "x@org.org"]
upper_test_emails = [e.upper() for e in emails if e.endswith("test.com")]
```

------

## 통합하자면?

```python
from typing import List, Iterable

BLACKLIST = {"bob"}

def is_blacklisted(name: str) -> bool:
    return name.lower() in BLACKLIST

def is_adult_with_valid_id(age: int, has_id: bool) -> bool:
    return has_id and age >= 21

def allowed_people(rows: Iterable[tuple[str, int, bool, str]]) -> List[str]:
    """
    rows: (name, age, has_id, email)
    return: 입장 허용자의 이메일 목록(대문자)
    """
    allowed = []
    for name, age, has_id, email in rows:
        if not is_blacklisted(name) and is_adult_with_valid_id(age, has_id):
            allowed.append(email)
    return [e.upper() for e in allowed]

def main() -> None:
    rows = [
        ("Bob", 40, True, "bob@club.com"),
        ("James", 29, True, "james@club.com"),
        ("Amy", 20, True, "amy@club.com"),
        ("Tom", 25, False, "tom@club.com"),
    ]
    print(allowed_people(rows))  # ["JAMES@CLUB.COM"]

if __name__ == "__main__":
    main()
```

- `__main__` 가드 + `main()` 엔트리포인트.
- **작은 함수**로 정책 분리.
- **타입 애너테이션**으로 인터페이스 명확화.
- **컴프리헨션**으로 최종 변환을 간결하게.

------

## 요약하자면?

| 습관                   | 핵심 포인트                           | 즉효성 체크리스트                           |
| ---------------------- | ------------------------------------- | ------------------------------------------- |
| `__main__` 가드        | 임포트 시 실행 차단, 테스트/실행 분리 | 모듈 하단 실행 코드는 반드시 가드 안으로    |
| `main()` 엔트리포인트  | 흐름 가시성, 실행 통제                | `main()` + 가드 조합이 기본 골격            |
| 작은 함수, 재사용      | 관심사 분리, 테스트 쉬움              | 한 함수 한 책임(SRP), 정책은 별도 함수화    |
| 타입 애너테이션 + mypy | 문서화 + 사전 오류 탐지               | 핵심 경로/공용 API부터 타입 지정, CI에 mypy |
| 리스트 컴프리헨션      | 간결·고성능 필터/변환                 | 변수명 의미 있게, 복잡해지면 함수로 분리    |
