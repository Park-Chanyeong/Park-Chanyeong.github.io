---
layout: single
title: "airflow"
categories: sysyem
tag: [blog,docker,프로그래머스4기]
search: true
typora-root-url: ../












---



**[**DOCKER]**[Docker의 필요성과 기본 개념](https://park-chanyeong.github.io)
{: .notice--primary}

### Docker의 필요성과 기본 개념

---

### **Docker란 무엇인가?**

Docker는 소프트웨어를 **일관되게 빌드, 실행, 배포**할 수 있는 플랫폼임. 주로 개발 환경과 운영 환경 간의 불일치 문제를 해결하기 위해 사용됨. 예를 들어, 내가 만든 프로그램이 다른 컴퓨터에서 실행되지 않는 문제는 아래와 같은 이유 때문일 수 있음:

1. 중요한 파일 누락.
2. 라이브러리나 의존성의 버전 차이.
3. 환경 설정의 차이.

이러한 문제를 해결하기 위해 Docker는 애플리케이션과 해당 의존성을 포함한 독립적인 실행 환경을 제공함. 이 환경은 **Docker Image**라는 형태로 패키징되어 **Docker Container**에서 실행됨. Docker를 사용하면 여러 개발자들이 같은 환경에서 개발할 수 있기 때문에 협업이 훨씬 수월해짐. 또한, 코드가 어느 환경에서나 동일하게 실행되기 때문에 배포 시에도 예기치 못한 오류를 줄일 수 있음.

Docker는 기존의 가상 머신과는 다른 방식으로 격리된 환경을 제공함. 가상 머신은 전체 운영 체제를 가상화하여 자원 소모가 크지만, Docker는 호스트 운영 체제를 공유하면서 필요한 부분만 가상화하기 때문에 더 경량화되어 있음. 이러한 특성 덕분에 빠른 시작 시간과 적은 자원 소비로 많은 애플리케이션을 동시에 실행할 수 있음.

---

### **Docker의 주요 개념**

1. **Docker Image**
   - 소프트웨어 실행에 필요한 모든 구성 요소를 포함한 불변 패키지임. 이미지에는 애플리케이션 코드, 라이브러리, 종속성 등이 포함되어 있어 어떤 환경에서도 동일하게 동작할 수 있음.
   - 예: Python 3.8, 특정 라이브러리, 실행 코드 등이 포함된 이미지.

2. **Docker Container**
   - 이미지를 실행한 독립적인 환경임. 컨테이너는 이미지를 기반으로 생성되며, 격리된 환경에서 애플리케이션이 동작하도록 함.
   - 컨테이너 내부는 호스트 운영체제와 격리되어 동작함. 이로 인해 컨테이너 내부에서 실행되는 애플리케이션은 호스트의 영향을 받지 않음.

#### **Dockerfile 예시**

아래는 간단한 Node.js 애플리케이션을 컨테이너화하기 위한 Dockerfile 예제임:

```dockerfile
# 베이스 이미지로 경량 Node.js 선택
FROM node:alpine

# 애플리케이션 파일 복사
COPY . /app

# 작업 디렉토리 설정
WORKDIR /app

# 애플리케이션 실행
CMD ["node", "app.js"]
```

Dockerfile은 Docker 이미지를 만들기 위한 설정 파일임. 위의 Dockerfile에서는 Node.js의 경량 이미지인 `node:alpine`을 베이스로 사용하고 있음. 애플리케이션 파일을 컨테이너 내부로 복사하고, 해당 디렉토리에서 `node app.js` 명령을 실행하도록 설정되어 있음.

이 Dockerfile을 기반으로 Docker 이미지를 생성할 수 있음:

```bash
# Docker 이미지 빌드
docker build -t my-node-app .
```

생성된 이미지를 실행하려면 다음 명령을 사용하면 됨:

```bash
docker run -d --name my-node-container my-node-app
```

위 명령어는 `my-node-app`이라는 이미지를 기반으로 컨테이너를 생성하고, 백그라운드에서 실행되도록 설정함. 컨테이너의 이름은 `my-node-container`로 지정하였음.

---

### **Virtual Machine vs. Docker**

Docker의 경량성과 효율성은 전통적인 가상 머신(Virtual Machine)과 비교했을 때 더욱 두드러짐. Docker는 운영체제를 가상화하는 대신 애플리케이션 레벨에서 가상화를 제공함으로써 가상 머신보다 훨씬 가볍고 빠름.

| **항목**        | **Virtual Machine**         | **Docker Container**       |
| --------------- | --------------------------- | -------------------------- |
| **가상화 레벨** | 하드웨어                    | 운영체제(OS)               |
| **속도**        | 느림 (OS 부팅 필요)         | 빠름 (초 단위 실행)        |
| **리소스 소비** | 높음 (OS별 메모리/CPU 사용) | 낮음 (호스트 OS 자원 공유) |
| **독립성**      | OS 단위 격리                | 프로세스 단위 격리         |

Virtual Machine은 각 VM마다 자체 운영체제를 포함하고 있어 자원 소모가 큼. 반면, Docker는 호스트 운영체제를 공유하기 때문에 더 적은 자원으로 많은 컨테이너를 실행할 수 있음. VM은 각기 다른 OS를 사용해야 할 때 유용하지만, 같은 OS에서 여러 애플리케이션을 실행할 때는 Docker가 훨씬 효율적임.

---

### **Docker가 필요한 이유**

1. **환경 간 일관성 유지**
   - 개발 환경과 운영 환경이 동일하여, "내 컴퓨터에서는 잘 되는데?"라는 문제를 방지할 수 있음. 개발자가 만든 코드를 Docker 이미지로 패키징하면, 해당 이미지를 다른 환경에서도 동일하게 실행할 수 있음.
2. **경량화된 자원 사용**
   - 하나의 호스트에서 수십, 수백 개의 컨테이너를 실행 가능함. 기존의 가상 머신 방식보다 훨씬 적은 자원으로 많은 작업을 수행할 수 있음. Docker는 운영체제를 포함하지 않기 때문에 컨테이너 자체가 매우 가벼움.
3. **배포 간소화**
   - Docker Hub 같은 이미지 레지스트리에 이미지를 업로드하여 손쉽게 배포 가능함. 이미지를 레지스트리에 저장해두면 다른 팀원이나 서버에서도 손쉽게 가져다가 사용할 수 있음. 이를 통해 배포 시간이 단축되고, 배포 과정에서 발생할 수 있는 오류를 최소화할 수 있음.

Docker를 사용하면 애플리케이션의 환경 설정, 종속성, 실행 방법 등을 모두 코드로 정의할 수 있기 때문에 인프라를 코드로 관리하는 **Infrastructure as Code** 개념을 실현할 수 있음. 이를 통해 개발과 운영의 경계를 허물고, 더 빠른 배포와 테스트가 가능해짐.

---

### **추가 실습 코드: Python 애플리케이션 컨테이너화**

다음은 간단한 Python Flask 애플리케이션을 컨테이너화하는 예시임. Flask는 파이썬으로 작성된 경량 웹 프레임워크로, Docker와 함께 간단한 웹 애플리케이션을 테스트할 때 자주 사용됨.

#### Flask 애플리케이션 코드 (`app.py`):

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello, Docker!"

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5000)
```

위 코드에서는 간단한 "Hello, Docker!" 메시지를 반환하는 Flask 웹 애플리케이션을 정의하고 있음. 이 애플리케이션은 5000번 포트에서 실행됨.

#### Dockerfile:

```dockerfile
# Python 베이스 이미지 사용
FROM python:3.8-slim

# 작업 디렉토리 설정
WORKDIR /app

# 요구사항 파일 복사 및 설치
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt

# 애플리케이션 코드 복사
COPY . .

# Flask 애플리케이션 실행
CMD ["python", "app.py"]
```

Dockerfile에서는 Python 3.8 slim 버전을 베이스로 사용하고 있음. `requirements.txt` 파일을 통해 필요한 패키지를 설치하고, 애플리케이션 코드를 컨테이너 내부로 복사한 뒤 Flask 애플리케이션을 실행하도록 설정함.

#### 요구사항 파일 (`requirements.txt`):

```txt
flask==2.0.3
```

Flask를 설치하기 위한 요구사항 파일임. 해당 파일을 통해 Flask 버전 2.0.3을 설치하게 됨.

#### 실행 명령:

```bash
# 이미지 빌드
docker build -t flask-app .

# 컨테이너 실행
docker run -d -p 5000:5000 --name flask-container flask-app
```

위 명령어를 통해 Docker 이미지를 빌드하고, 5000번 포트를 매핑하여 컨테이너를 실행함. 이제 브라우저에서 `http://localhost:5000`에 접속하면 "Hello, Docker!" 메시지를 확인할 수 있음.

컨테이너를 실행할 때 `-d` 옵션을 사용하면 백그라운드에서 실행되며, `-p` 옵션을 통해 호스트와 컨테이너의 포트를 매핑함. 이를 통해 외부에서 컨테이너 내부의 애플리케이션에 접근할 수 있게 됨.

---

이 포스팅은 Docker의 기본 개념과 필요성, 그리고 실제 코드를 활용한 컨테이너화 과정을 다룸. Docker는 애플리케이션을 일관되게 실행할 수 있도록 도와주는 강력한 도구이며, 이를 통해 개발과 운영 환경의 차이를 줄일 수 있음. 다음 포스팅에서는 **Docker Compose를 이용한 멀티 컨테이너 환경 구축**이나 **실제 데이터베이스 연동**에 대해 다룰 예정임. Docker Compose를 사용하면 여러 개의 컨테이너를 정의하고, 손쉽게 관리할 수 있기 때문에 복잡한 애플리케이션을 쉽게 구성할 수 있음. 또한, 데이터베이스와 웹 애플리케이션을 동시에 컨테이너화하여 테스트하는 방법도 다룰 계획임.